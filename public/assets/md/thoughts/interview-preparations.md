## Leadership examples

Aspects to keep in mind

- Speak to complexity of larger projects
- Refer to times of project ownership

### Release manager at REI

- Created documentation for 10+ teams
- I became an expert best practices for component use
- Started and maintained end to end tests for deployment verification

### Architecting for content creation at REI

- Discovered multiple team needs
- Discovery on proposed technical solutions
- Advocated for a D.R.Y. approach by using reusable components
- Worked with FE & BE developers to implement a modular system

### Creating a checkout experience at Veyl

- Architecting deployment patterns for multiple domains
- Preseting approaches to CTO and the proposed solution
- Owner of project, all major features, and all bugs
- Guided two other developers to contribute
- Created detailed documentation for future developers

### Lead React Native application at Guild Mortgage

- After onboarding into the project, revamped state management within the app
- Created reusable components and championed the initiative within the team

### Architected the Customer Portal at Guild Mortage

- Created a deployment pipeline
- Developed an integration and migration strategy
- Led a team of developers and executed the successful of a new customer portal

## Apple Behavioral Questions

### Little to no direction: Checkout App

- Very little design direction and storyboarding
- Needed to architect supporting multiple brands with a single deployment
- Many UX decisions were made at development time
- Many feature requests, but with little requirements

### Working outside of my role: Guild Mortgage

- Lots of frontend mentoring for coworkers on projects I was not invovled in
- Setup CI development pipelines
- Architected data integration of React development with legacy PHP websites
- Created React boilerplate templates for internal teams

### Why Apple and why this role

- The level of standards Apple holds aligns with my own values
- I appreciate that with Apple products and solutions, you know it will be of quality
- I generally prefer fewer products, but of high quality and thought
- Eager to contribute and test my skills and leadership with talented people that are also kind and motivated

### Analytical thinking: Component library creation at REI

- Decided how a layout component would work by analyzing all currnet uses cases and creating a solution for most
- Lots of decisions about which features to include and how they would relate to future components
- Decisions would impact frontend development for all teams at REI

### Why I fit the role

- Strong UX background, familiar with common website patterns, user behavior, know how to make an accessible website, and I am highly collaborative
- Great at debugging and working through complex issues can come up with both internal and external services
- Motivated, proactive, and can usually find ways to support and help a project proceed and succeed
- Strong listening skills for both technical discussions and planning development

### Customer service orientation: CMS creation process

- Advocated for a better user experience when creating content
- Architected a way for reusable components and content that would save time

### Inquisitiveness: Build tools at Sony

- Upgraded internal tools for building web apps in addition to regular tasks

### Innovation: Checkout page

- Created a way, based on the URL, to output a different version of a checkout app
- Each brand had it's own URL, but all URLs pointed to the same deployment

### Problem solving: supporting teams at REI

- I was the main point of contact for the component library that all frontend developers relied on
- My process was to first listen, then to replicate the issue and context of any problems

### Communication

- When things are difficult to understand or tensions are high, breaking down a situation into smaller parts can often help

## 7 steps to solving problems

1. Listen:

- Listen for clues
- Details help solve optimally
- Ask clarifying questions
- Examine edge cases, if needed

2. Draw an example

- Use large examples
- Use generic examples

3. Start with brute force

- Something better than nothing
- State runtime, then optimize
- Try something, then correct
- Note the time and memory complexity

4. Optimize
- Sometimes just talk brute force
- Most time here

5. Walk through algorithm

- Walk through before writing code
- Make sure you know you're doing before starting to code

6. Write code

- Might not need to actually execute code
- They want to know your thought process
- Make it as bug free as possible

7. Verification

- Look for any last improvements
- Show you care about quality
- Talk about current bottlenecks in solution

## Leet code patterns

### Binary search
- Works when data is sorted, divide in half recusrively
- Prefix sum: save time with precalculated values
- Examples: 303, 325, 560

### Two pointers
- Pointers start at ends or middle, meet or disperse
- Examples: 167, 15, 11

### Sliding window
- When a max length is given and working with array
- Examples: 643, 3, 76

### Fast and slow pointers
- Check if linked list has a cycle
- The two pointers will meet if something is a cycle
- Examples: 141, 202, 287

### Rearranging a link list
- Do it in place with a previous, current, and next pointers
- Examples: 206, 92, 24

### Monotonic stack
- Finding next greater or next smallest in array
- Use a new stack array to track indexes
- Examples: 496, 739, 84

### Top K elements
- Use a min heap of size K
- Examples: 215, 347, 373

### Overlapping intervals
- Sort by start time
- Go one by one to new
- Examples: 561, 57, 435

### Modified binary search
- Find sorted parts
- Sort each half
- Examples: 33, 153, 240

### Binary tree reversal
- Left to right, right to left, at each level
- Examples: 257, 230, 124, 107

### Depth first search (DFS)
- Keep track of visited nodes
- Perform operation on current node
- Explore unvisited neighbors
- Examples: 133, 131, 210

### Breadth first search (BFS)
- Level by level
- Shortest path between two nodes
- Transforming words
- Use a queue, add starting node to it
- Track visited, process current, and add neighbors to queue
- Examples: 102, 994, 127

### Matrix reversal
- Use DFS/BFS
- Find shortest path in grid
- Examples: 733, 200, 130

### Backtracking
- Generating permutations
- Include and element or not, go to next, then in reverse
- Examples: 46, 78, 51, 17

### Dynamic programming
- Examples: 70, 322, 1143, 300, 416, 312
